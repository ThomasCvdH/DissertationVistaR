# Function to create a time series data frame comparing two days
create_timeseries_df <- function(
    raw_df, dataset = "timeseries",
    day1 = 1, day2 = 2) {
  # Automatically generate the time map and get regex patterns 
  time_map <- get_time_mapping2() # Map timepoints to hours and days
  regex <- get_regex_patterns2(dataset) # Get regex patterns for sample name parsing

  # Ensure the function is used with mapped pattern types
  if (regex$pattern_type != "mapped") {
    stop("This function is designed for the 'timeseries' dataset.")
  }
  if (!"day" %in% colnames(time_map)) {
    stop("The 'time_map' generated by get_time_mapping2() must contain a 'day' column.")
  }

  # Find all timepoints for the two specified days 
  timepoints_day1 <- time_map %>%
    filter(day == .env$day1) %>%
    pull(timepoint)

  timepoints_day2 <- time_map %>%
    filter(day == .env$day2) %>%
    pull(timepoint)

  # Check that timepoints exist for both days
  if (length(timepoints_day1) == 0 || length(timepoints_day2) == 0) {
    stop(paste("Could not find any timepoints in time_map for days", day1, "and/or", day2))
  }

  comparison_timepoints <- c(timepoints_day1, timepoints_day2)

  #Pivot data to long format and extract metadata from sample names 
  long_df <- raw_df %>%
    tibble::rownames_to_column(var = "transcript_id") %>%
    pivot_longer(
      cols = -transcript_id,
      names_to = "sample",
      values_to = "abundance"
    ) %>%
    # Extract metadata using regex patterns
    mutate(
      timepoint = as.character(str_extract(sample, regex$timepoint)),
      condition = str_extract(sample, regex$condition_group),
      replicate = str_extract(sample, regex$rep)
    ) %>%
    # Filter for relevant timepoints and valid conditions
    filter(timepoint %in% comparison_timepoints, !is.na(condition))

  # Check that filtering did not remove all rows
  if (nrow(long_df) == 0) {
    stop("Filtering resulted in zero rows. Check regex patterns and that sample names match the time_map.")
  }

  #  Dynamically find the time offset for the second day 
  day2_offset <- time_map %>%
    filter(day == .env$day2) %>%
    summarise(min_time = min(time_h, na.rm = TRUE)) %>%
    pull(min_time)

  # Ensure the offset is valid
  if (is.infinite(day2_offset)) {
    stop(paste("Could not determine the starting time for day", day2, "from the time_map."))
  }

  cat(paste("Using a dynamic time offset for day", day2, "of:", day2_offset, "hours\n"))

  #  Join with time_map, adjust time, and create new headers.
  # Links extracted timepoint IDs to actual day and hour values.
  prepared_df <- long_df %>%
    left_join(time_map, by = "timepoint") %>%
    mutate(
      # Adjust time for day2 by subtracting the offset, keep original for day1.
      adjusted_time_h = if_else(day == .env$day2, time_h - day2_offset, time_h),
      # Create a new header for each sample
      new_header = paste(condition, paste0(adjusted_time_h, "h"), replicate, sep = "_")
    ) %>%
    dplyr::select(transcript_id, new_header, abundance)

  #  Pivot back to wide format for final output.
  wide_df <- prepared_df %>%
    pivot_wider(
      names_from = new_header,
      values_from = abundance
    ) %>%
    tibble::column_to_rownames(var = "transcript_id")

  # Return the final wide-format data frame for downstream analysis
  return(wide_df)
}

# Function to get regex patterns for different datasets
get_regex_patterns2 <- function(dataset) {
  # Define base patterns common to all datasets unless specified otherwise
  base_patterns <- list(
    tair_code = "AT.G\\d+",
    transcript_suffix = "\\.\\d+$"
  )

  # Select patterns according to dataset type
  if (dataset == "adam") {
    # Patterns for adam dataset
    c(list(
      condition_group = "^X\\d+",
      time_h = "(?<=\\.X)(\\d+)(?=H)",
      rep = "\\.X\\d+$",
      pattern_type = "direct"
    ), base_patterns)
  } else if (dataset == "coolLL2") {
    # Patterns for coolLL2 dataset
    c(list(
      condition_group = "^X\\d+C",
      time_h = "(?<=\\.X)(\\d+)(?=h)",
      rep = "\\.rep\\d+$",
      pattern_type = "direct"
    ), base_patterns)
  } else if (dataset == "timeseries") {
    # Patterns for timeseries dataset
    c(list(
      condition_group = "X\\d+",
      timepoint = "(?<=T)\\d+",
      rep = "\\.rep\\d+$",
      pattern_type = "mapped"
    ), base_patterns)
  } else {
    stop("Unknown dataset for regex patterns")
  }
}

# Function to generate a mapping of timepoints to hours, days, and periods
get_time_mapping2 <- function() {
  timepoints <- 1:26
  hours <- numeric(length(timepoints))
  periods <- character(length(timepoints))

  # Set the first timepoint hour
  hours[1] <- 0
  # Calculate hours for each timepoint based on experimental design
  for (t in 2:length(timepoints)) {
    if (t <= 11) {
      hours[t] <- hours[t - 1] + 3
    } else if (t %in% 12:13) {
      hours[t] <- hours[t - 1] + 1.5
    } else if (t > 13 && t <= 18) {
      hours[t] <- hours[t - 1] + 3
    } else if (t == 19) {
      hours[t] <- hours[t - 1] + 48
    } else {
      hours[t] <- hours[t - 1] + 3
    }
  }
  # Assign periods based on timepoint number
  periods[timepoints <= 18] <- "Initial Period (T1-T18)"
  periods[timepoints > 18] <- "Post-Gap Period (T19-T26)"

  # Return a tibble mapping timepoint to hour, day, and period
  tibble::tibble(
    timepoint = as.character(timepoints),
    time_h = hours,
    day = case_when(
      as.numeric(timepoint) <= 9 ~ 1, # T1-T9 is Day 1 (0-24h)
      as.numeric(timepoint) <= 18 ~ 2, # T10-T18 is Day 2 (27-48h)
      TRUE ~ 3 # T19 onwards is Day 3 (96h+)
    ),
    period = factor(periods,
      levels = c("Initial Period (T1-T18)", "Post-Gap Period (T19-T26)")
    )
  )
}